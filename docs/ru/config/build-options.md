# Варианты Сборки

Если не указано, варианты в этом разделе применяются только к сборке.

## build.target

- **Тип:** `string | String [] `
- **По умолчанию:** `'modules'`
- **Связанный:** [совместимость браузера](/en/guide/build#browser-compatibility)

Цель совместимости браузера для последнего пакета. Значение по умолчанию является специальным значением VITE, `'modules'` , которое нацелено на браузеры с [нативными модулями ES](https://caniuse.com/es6-module) , [нативным динамическим импортом ESM](https://caniuse.com/es6-module-dynamic-import) и [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta) поддержкой. VITE заменит `'modules'` до `['es2020', 'edge88', 'firefox78', 'chrome87', 'safari14']`

Другое специальное значение - `'esnext'` - которое предполагает поддержку нативного динамического импорта и будет выполнять только минимальное транспортировку.

Преобразование выполняется с помощью ESBUILD, и значение должно быть допустимой [целевой опцией ESBUILD](https://esbuild.github.io/api/#target) . Пользовательские цели могут быть версией ES (например, `es2015` ), браузером с версией (например, `chrome58` ), либо массивом нескольких целевых строк.

ПРИМЕЧАНИЕ. Сборка не будет выполнена, если код содержит функции, которые не могут быть безопасно транспонированы Esbuild. Смотрите [документы Esbuild](https://esbuild.github.io/content-types/#javascript) для получения более подробной информации.

## build.modulePreload

- **Тип:** `Boolean | {Polyfill?: Boolean, ResolvedEpendences?
- **По умолчанию:** `{ polyfill: true }`

По умолчанию [многофиль предварительной нагрузки модуля](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill) автоматически вводится. Полифилл автоматически вводится в прокси -модуль каждой записи `index.html` . Если сборка настроена на использование не HTML-пользовательской записи через `build.rollupOptions.input` , то необходимо вручную импортировать полифилл в вашей пользовательской записи:

```js
import 'vite/modulepreload-polyfill'
```

ПРИМЕЧАНИЕ. Полифилл **не** применяется к [режиму библиотеки](/en/guide/build#library-mode) . Если вам нужно поддерживать браузеры без нативного динамического импорта, вам, вероятно, следует избегать использования его в своей библиотеке.

Полифилл может быть отключен с помощью `{ polyfill: false }` .

Список кусков в предварительную загрузку для каждого динамического импорта вычисляется с помощью VITE. По умолчанию абсолютный путь, включающий `base` будет использоваться при загрузке этих зависимостей. Если `base` является относительным ( `''` или `'./'` ), `import.meta.url` используется во время выполнения, чтобы избежать абсолютных путей, которые зависят от окончательной развернутой базы.

Существует экспериментальная поддержка мелкого контроля над списком зависимостей и их путей с использованием функции `resolveDependencies` . [Дайте обратную связь](https://github.com/vitejs/vite/discussions/13841) . Он ожидает функции типа `ResolveModulePreloadDependenciesFn` :

```ts
type ResolveModulePreloadDependenciesFn = (
  url: string,
  deps: string[],
  context: {
    hostId: string
    hostType: 'html' | 'js'
  },
) => string[]
```

Функция `resolveDependencies` будет вызвана для каждого динамического импорта со списком кусков, от которых она зависит, и она также будет вызвана для каждой куски, импортируемой в файлах HTML входа. Новый массив зависимостей может быть возвращен с этими фильтрованными или более введенными зависимостями, и их пути модифицированы. `deps` пути относительно `build.outDir` . Возвратное значение должно быть относительным путем к `build.outDir` .

```js twoslash
/** @type {import ('vite'). userconfig} */
const config = {
  // Краттей-юнор
  build: {
    // --- Раньше ---
    modulePreload: {
      resolveDependencies: (filename, deps, { hostId, hostType }) => {
        return deps.filter(condition)
      },
    },
    // --- Резать после ---
  },
}
```

Решенные пути зависимости могут быть дополнительно изменены с использованием [`experimental.renderBuiltUrl`](../guide/build.md#advanced-base-options) .

## build.polyfillModulePreload

- **Тип:** `boolean`
- **По умолчанию:** `true`
- **Униженное** использование `build.modulePreload.polyfill` вместо этого

Автоматически вводить [модульный предварительный полифилл](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill) .

## build.outDir

- **Тип:** `string`
- **По умолчанию:** `dist`

Укажите выходной каталог (по сравнению с [корнем проекта](/en/guide/#index-html-and-project-root) ).

## build.assetsDir

- **Тип:** `string`
- **По умолчанию:** `assets`

Укажите каталог на гнездо, сгенерированные активами в соответствии с (относительно `build.outDir` Это не используется в [библиотечном режиме](/en/guide/build#library-mode) ).

## build.assetsInlineLimit

- **Тип:** `number` | `((filePath: String, Content: Buffer) => Boolean | неопределенно) `
- **По умолчанию:** `4096` (4 киб)

Импортированные или ссылочные активы, которые меньше, чем этот порог, будут вставлены в качестве URL -адреса Base64, чтобы избежать дополнительных HTTP -запросов. Установите на `0` , чтобы отключить внедрение вообще.

Если обратный вызов пройден, логический может быть возвращен в выбор или отказаться. Если ничего не возвращается, применяется логика по умолчанию.

Заполнители GIT LFS автоматически исключаются из INLINGING, поскольку они не содержат содержания файла, который они представляют.

::: tip Note
Если вы указываете `build.lib` , `build.assetsInlineLimit` будет игнорироваться, а активы всегда будут вставлены, независимо от размера файла или быть заполнителем GIT LFS.
:::

## build.cssCodeSplit

- **Тип:** `boolean`
- **По умолчанию:** `true`

Включить/отключить разделение кода CSS. При включении CSS, импортированные в асинхронные куски JS, будут сохранены как кусочки и извлечены вместе при получении куски.

Если отключено, все CSS во всем проекте будут извлечены в один файл CSS.

::: tip Note
Если вы указате `build.lib` , `build.cssCodeSplit` будет `false` по умолчанию.
:::

## build.cssTarget

- **Тип:** `string | String [] `
- **По умолчанию:** так же, как [`build.target`](#build-target)

Эта опция позволяет пользователям установить другую цель браузера для минификации CSS из той, которая используется для транспиляции JavaScript.

Он должен использоваться только тогда, когда вы нацеливаетесь на браузер, не являющийся Mainestream.
Одним из примеров является Android WeChat Webview, который поддерживает большинство современных функций JavaScript, но не [`#RGBA` шестнадцатеричного цветового нотации в CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb_colors) .
В этом случае вам нужно установить `build.cssTarget` до `chrome61` , чтобы предотвратить преобразование `rgba()` цвета в `#RGBA` шестнадцатеричных обозначения.

## build.cssMinify

- **Тип:** `Boolean | 'esbuild' | 'Lightningcss'
- **По умолчанию:** то же самое, что и [`build.minify`](#build-minify) для клиента, `'esbuild'` для SSR

Эта опция позволяет пользователям переопределять MINIFICE CSS специально вместо дефолта на `build.minify` , поэтому вы можете настроить министерство для JS и CSS отдельно. Vite использует `esbuild` по умолчанию для министерства CSS. Установите опцию на `'lightningcss'` , чтобы использовать [Lightning CSS](https://lightningcss.dev/minification.html) вместо этого. Если выбрано, его можно настроить с помощью [`css.lightningcss`](./shared-options.md#css-lightningcss) .

## build.sourcemap

- **Тип:** `Boolean | 'в соответствии' | «Скрытый»
- **По умолчанию:** `false`

Генерировать карты источника производства. Если `true` , будет создан отдельный файл Sourcemap. Если `'inline'` , Sourcemap будет добавлен в полученный выходной файл в качестве URI данных. `'hidden'` Работает как `true` , за исключением того, что соответствующие комментарии Sourcemap в комплекте файлах подавляются.

## build.rollupOptions

- **Тип:** [`RollupOptions`](https://rollupjs.org/configuration-options/)

Прямо настраивать базовый пакет рулона. Это то же самое, что и параметры, которые можно экспортировать из файла конфигурации ROLLUP, и будет объединен с вариантами внутренних развертывания VITE. Смотрите [Docs Options Docs](https://rollupjs.org/configuration-options/) для получения более подробной информации.

## build.commonjsOptions

- **Тип:** [`RollupCommonJSOptions`](https://github.com/rollup/plugins/tree/master/packages/commonjs#options)

Параметры, чтобы перейти на [@rollup/plugin-commonjs](https://github.com/rollup/plugins/tree/master/packages/commonjs) .

## build.dynamicImportVarsOptions

- **Тип:** [`RollupDynamicImportVarsOptions`](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#options)
- **Связанный:** [динамический импорт](/en/guide/features#dynamic-import)

Параметры, чтобы перейти на [@Rollup/Plagin-Dynamic-Import-VARS](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars) .

## build.lib

- **Тип:** `{inpit: строка | нить[] | {[entaralias: string]: string}, name?: string, formats?: ('es' | 'cjs' | 'Umd' | 'iife') [], имя файла?: строка | ((Format: ModuleFormat, rentname: string) => string), cssfilename?: String} `
- **Связанный:** [библиотечный режим](/en/guide/build#library-mode)

Построить как библиотека. `entry` требуется, поскольку библиотека не может использовать HTML в качестве входа. `name` является открытой глобальной переменной и требуется, когда `formats` включает `'umd'` или `'iife'` . По умолчанию `formats` - `['es', 'umd']` или `['es', 'cjs']` , если используются несколько записей.

`fileName` - это имя вывода файла пакета, которое по умолчанию по умолчанию `"name"` в `package.json` . Он также может быть определен как функция, принимающая `format` и `entryName` в качестве аргументов и возвращение имени файла.

Если ваш пакет импортирует CSS, `cssFileName` можно использовать для указания имени вывода файла CSS. Он по умолчанию к тому же значению, что и `fileName` если он устанавливает строку, в противном случае он также возвращается к `"name"` в `package.json` .

```js twoslash [vite.config.js]
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    lib: {
      entry: ['src/main.js'],
      fileName: (format, entryName) => `my-lib-${entryName}.${format}.js`,
      cssFileName: 'my-lib-style',
    },
  },
})
```

## build.manifest

- **Тип:** `Boolean | String`.
- **По умолчанию:** `false`
- **Связанный:** [интеграция бэкэнд](/en/guide/backend-integration)

Создать ли манифестный файл, который содержит отображение непреднамеренных имен файлов активов с их хэшированными версиями, которые затем могут использоваться в сфере сервера для визуализации правильных ссылок активов.

Когда значение является строкой, оно будет использоваться в качестве пути манифестного файла относительно `build.outDir` . Когда установлено на `true` , путь будет `.vite/manifest.json` .

## build.ssrManifest

- **Тип:** `Boolean | String`.
- **По умолчанию:** `false`
- **Связанный:** [рендеринг на стороне сервера](/en/guide/ssr)

Создавать ли манифестный файл SSR для определения ссылок на стиль и директив предварительной нагрузки активов в производстве.

Когда значение является строкой, оно будет использоваться в качестве пути манифестного файла относительно `build.outDir` . Когда установлено на `true` , путь будет `.vite/ssr-manifest.json` .

## build.ssr

- **Тип:** `Boolean | String`.
- **По умолчанию:** `false`
- **Связанный:** [рендеринг на стороне сервера](/en/guide/ssr)

Производить SSR-ориентированную сборку. Значение может быть строкой для непосредственного указания записи SSR, или `true` , что требует указания записи SSR через `rollupOptions.input` .

## build.emitAssets

- **Тип:** `boolean`
- **По умолчанию:** `false`

Во время строительства, не являющихся клиентами, статические активы не испускаются, поскольку предполагается, что они будут излучены как часть клиентской сборки. Эта опция позволяет фреймворкам заставлять их излучать в других средах. Ответственность за рамки объединить активы с шагом после сборки.

## build.ssrEmitAssets

- **Тип:** `boolean`
- **По умолчанию:** `false`

Во время сборки SSR статические активы не испускаются, так как предполагается, что они будут излучены как часть сборки клиента. Эта опция позволяет фреймворкам заставлять их излучать как в сборке клиента, так и в сборке SSR. Ответственность за рамки объединить активы с шагом после сборки. Эта опция будет заменена на `build.emitAssets` , как только среда API стабилен.

## build.minify

- **Тип:** `Boolean | 'terser' | 'esbuild'
- **По умолчанию:** `'esbuild'` для сборки клиента, `false` для сборки SSR

Установите на `false` , чтобы отключить минивер или указать минивер для использования. По умолчанию [ESBUILD](https://github.com/evanw/esbuild) , которая на 20 ~ 40 раз быстрее, чем Terser, и только на 1 ~ 2% худшее сжатие. [Тесты](https://github.com/privatenumber/minification-benchmarks)

Примечание `build.minify` Параметр не минимизирует пробелы при использовании формата `'es'` в режиме LIB, так как он удаляет чистые аннотации и ломает удаление деревьев.

Терсер должен быть установлен, когда он установлен на `'terser'` .

```sh
npm add -D terser
```

## build.terserOptions

- **Тип:** `TerserOptions`

Дополнительные [варианты Minify](https://terser.org/docs/api-reference#minify-options) , чтобы передать Terser.

Кроме того, вы также можете передать опцию `maxWorkers: number` , чтобы указать максимальное количество работников для появления. По умолчанию количество процессоров минус 1.

## build.write

- **Тип:** `boolean`
- **По умолчанию:** `true`

Установите `false` , чтобы отключить написание пакета на диск. Это в основном используется в [программных вызовах `build()`](/en/guide/api-javascript#build) , где необходима дальнейшая после обработки пакета перед написанием на диск.

## build.emptyOutDir

- **Тип:** `boolean`
- **По умолчанию:** `true` если `outDir` находится внутри `root`

По умолчанию VITE опустошит `outDir` на сборке, если он находится внутри root Project. Он излучит предупреждение, если `outDir` находится за пределами корня, чтобы избежать случайного удаления важных файлов. Вы можете явно установить эту опцию, чтобы подавить предупреждение. Это также доступно через командную строку как `--emptyOutDir` .

## build.copyPublicDir

- **Тип:** `boolean`
- **По умолчанию:** `true`

По умолчанию Vite будет копировать файлы из `publicDir` в `outDir` на сборку. Установите `false` чтобы отключить это.

## build.reportCompressedSize

- **Тип:** `boolean`
- **По умолчанию:** `true`

Включить/отключить отчетность по размеру GZIP. Сжатие больших выходных файлов может быть медленным, поэтому отключение этого может повысить производительность сборки для крупных проектов.

## build.chunkSizeWarningLimit

- **Тип:** `number`
- **По умолчанию:** `500`

Ограничение для предупреждений размера куски (в КБ). Его сравнивают с несжатым размером чанка, поскольку [сам размер JavaScript связан со временем выполнения](https://v8.dev/blog/cost-of-javascript-2019) .

## build.watch

- **Тип:** [`WatcherOptions`](https://rollupjs.org/configuration-options/#watch) `| null`
- **По умолчанию:** `null`

Установите на `{}` чтобы включить Rollup Watcher. Это в основном используется в случаях, которые включают плагины только для сборки или процессы интеграции.

::: warning Using Vite on Windows Subsystem for Linux (WSL) 2

Есть случаи, которые просмотр файловой системы не работает с WSL2.
Смотрите [`server.watch`](./server-options.md#server-watch) для более подробной информации.

:::
