---
title: Vite 5.1出了！
author:
  name: The Vite Team
date: 2024-02-08
sidebar: false
head:
  - - meta
    - property: og:type
      content: website
  - - meta
    - property: og:title
      content: Announcing Vite 5.1
  - - meta
    - property: og:image
      content: https://vite.dev/og-image-announcing-vite5-1.png
  - - meta
    - property: og:url
      content: https://vite.dev/blog/announcing-vite5-1
  - - meta
    - property: og:description
      content: Vite 5.1 Release Announcement
  - - meta
    - name: twitter:card
      content: summary_large_image
---

# Vite 5.1出了！

_2024年2月8日_

![Vite 5.1公告封面图像](/0)

Vite 5于去年11月[发行](/0)，这代表了Vite和生态系统的另一个巨大飞跃。几周前，我们庆祝了每周的NPM下载量为1000万个，并为Vite Repo庆祝了900个贡献者。今天，我们很高兴宣布发布Vite 5.1。

快速链接:[文档](/0)， [ChangElog](/1)

其他语言的文档:[简体中文](/0)，[日本语](/1)， [español](/2) ， [português](/3) ， [한국어](/4) ， [deutsch](/5)

尝试在Stackblitz中尝试Vite 5.1在线: [Vanilla](/0) ， [Vue](/1) ， [React](/2) ， [reateact](/3) ， [Lit](/4) ，Svelte， [Svelte](/5) ， [Solid](/6) ， [Qwik](/7) 。

如果您是Vite的新手，我们建议您先阅读[入门](/0)和[指南](/1)。

要保持最新状态，请在[X](/0)或[Mastodon](/1)上关注我们。

## Vite运行时API

Vite 5.1为新的Vite Runtime API增加了实验支持。它可以通过首先使用Vite插件处理任何代码来运行任何代码。它与`server.ssrLoadModule`不同，因为运行时实现与服务器分离。这使库和框架作者在服务器和运行时之间实现了自己的通信层。该新的API旨在替换Vite当前的SSR原语，一旦稳定。

新的API带来了许多好处:

- SSR期间对HMR的支持。
- 它与服务器分离，因此可以使用单个服务器的客户有数量没有限制 - 每个客户端都有自己的模块缓存（您甚至可以与之通信 - 使用消息频道/获取呼叫/Direct call/Direct函数call/websocket）。
- 它不取决于任何节点/bun/deNo内置的API，因此可以在任何环境中运行。
- 与具有自己的机制运行代码的工具相集成很容易（您可以为跑步者提供使用`eval`而不是`new AsyncFunction` ）。

最初的想法[是由Pooya Parsa提出的](/0)，并由[Anthony Fu](/1)作为[Vite节点](/2)包装，以[供电NUXT 3 Dev SSR](/3) ，后来也用作[Vitest](/4)的基础。因此，Vite节点的总体想法已经进行了一段时间的战斗测试。这是[Vladimir Sheremet](/5)的API的新迭代，他已经重新启动了Vite节点，并在将其添加到Vite Core时，将API的知识更加强大和灵活。公关是在材料中的一年，您可以[在这里](/6)看到与生态系统维护者的演变和讨论。

::: info
Vite运行时API演变为模块Runner API，作为[环境API](/0)的一部分以Vite 6发布。
:::

## 特征

### 改善了对`.css?url`支持

将CSS文件导入为URL现在可靠，正确地工作。这是混音转向Vite的最后剩下的障碍。参见（ [＃15259](/0) ）。

### `build.assetsInlineLimit`现在支持回调

现在，用户可以[提供一个回调](/0)，该回调将返回布尔值以选择输入或退出特定资产的内部。如果返回`undefined` ，则应用默认逻辑。请参阅（ [＃15366](/1) ）。

### 改进的HMR用于循环进口

在Vite 5.0中，即使在客户端中可以很好地处理，圆形导入中接受的模块也总是触发整页重新加载。现在，这是放松的，以允许HMR在没有完整页面重新加载的情况下申请，但是如果在HMR期间发生任何错误，则该页面将被重新加载。请参阅（ [＃15118](/0) ）。

### 支持`ssr.external: true`外部化所有SSR软件包

从历史上看，Vite将除链接软件包以外的所有软件包外部化。此新选项也可用于强制外部化所有软件包，包括链接软件包。这在MonorePos中的测试中很方便，我们希望在其中模拟所有软件包的通常情况，或者在使用`ssrLoadModule`加载任意文件时，我们希望始终外部软件包，因为我们不关心HMR。参见（ [＃10939](/0) ）。

### 在预览服务器中公开`close`方法

预览服务器现在公开了一个`close`方法，该方法将正确拆除服务器，包括所有打开的套接字连接。请参阅（ [＃15630](/0) ）。

## 绩效改进

Vite在每个发行版中都会不断越来越快，Vite 5.1充满了性能的改进。我们使用[Vite-Dev-Server-perf](/0) for Vite 4.0的所有次要版本测量了10K模块（25级深树）的加载时间。这是衡量Vite无束方法的效果的好基准。每个模块是一个带有计数器的小型字样文件，并将其导入到树上的其他文件中，因此这主要衡量了执行请求单独模块所需的时间。在Vite 4.0中，加载10K模块在M1最大值上花费了8秒。我们在[Vite 4.3方面取得了突破，我们专注于性能](/1)，并且能够在6.35秒内加载它们。在Vite 5.1中，我们设法做了另一个性能飞跃。 Vite现在在5.35秒内提供10K模块。

![Vite 10K模块加载时间进度](/0)

该基准测试的结果在无头木偶仪上运行，是比较版本的好方法。他们并不能代表用户所经历的时间。当在隐身窗口中运行相同的10K模块时，我们有:

| 10K模块              | Vite 5.0 | Vite 5.1 |
| -------------------- | :------: | :------: |
| 加载时间             |  2892ms  |  2765ms  |
| 加载时间（缓存）     |  2778ms  |  2477ms  |
| 完整的重新加载       |  2003ms  |  1878ms  |
| 完整重新加载（缓存） |  1682ms  |  1604ms  |

### 在线程中运行CSS预处理器

Vite现在可以选择加入线程中的CSS预处理器。您可以使用[`css.preprocessorMaxWorkers: true`](/0)启用它。对于Vuetify 2项目，通过启用此功能，DEV启动时间减少了40％。 [PR中的其他设置进行了性能比较](/1)。参见（ [＃13584](/2) ）。[给予反馈](/3)。

### 改善服务器冷启动的新选择

您可以将`optimizeDeps.holdUntilCrawlEnd: false`设置为切换到DEPS优化的新策略，这可能有助于大型项目。我们正在考虑将来默认情况下切换到此策略。[给予反馈](/0)。 （ [＃15244](/1) ）

### 通过缓存的检查更快地解决

现在，默认情况下启用了`fs.cachedChecks`优化。在Windows中， `tryFsResolve`速度较快约14倍，并且在三角形基准测试中，整体分辨ID的速度高约5倍。 （ [＃15704](/0) ）

### 内部绩效改进

开发服务器具有多个增量性能增长。在304（ [＃15586](/0) ）上短路的新中间件。我们在热路径中避免了`parseRequest` （ [＃15617](/1) ）。现在，滚动已正确懒惰（ [＃15621](/2) ）

## 弃用

我们将在可能的情况下继续减少Vite的API表面，以使项目长期可维护。

### 弃用`import.meta.glob`中的`as`选项

该标准移至[导入属性](/0)，但我们不打算在这一点上用新选项替换`as` 。相反，建议用户切换为`query` 。参见（ [＃14420](/1) ）。

### 删除了实验构建时间预捆绑

删除了在VITE 3中添加的实验功能的构建时间预捆绑。随着Rollup 4将解析器切换到本机，Rolldown正在处理，因此此功能的性能和Dev-VS构建不一致的故事都不再有效。我们希望继续提高开发/建立一致性，并得出结论，将Rolldown用于“在开发过程中进行预险”和“生产构建”是更好的下注。 Rolldown还可以以比DEP预先筹集资金更有效的方式实施缓存。请参阅（ [＃15184](/0) ）。

## 介入

我们感谢[Vite Core的900个贡献者](/0)以及插件，集成，工具和翻译的维护者，这些插件，集成，工具和翻译不断推动生态系统的前进。如果您喜欢Vite，我们邀请您参加并帮助我们。查看我们的[贡献指南](/1)，并涉足[分类问题](/2)，[审查PR](/3) ，在[Github讨论](/4)中回答问题，并在[Vite Land的](/5)社区中帮助社区中的其他人。

## 致谢

Vite 5.1可以归功于我们的贡献者社区，生态系统中的维护者和[Vite团队](/0)。向个人和公司赞助Vite Development的大喊。招聘Vite团队成员的[Stackblitz](/1) ， [Nuxt Labs](/2)和[Astro](/3) 。以及[Vite的Github赞助商](/4)， [Vite的开放集体](/5)和[Evan您的Github赞助商的赞助商](/6)。
